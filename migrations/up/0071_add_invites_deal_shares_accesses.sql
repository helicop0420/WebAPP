CREATE EXTENSION if not exists citext;

CREATE DOMAIN email AS citext
  CHECK ( value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );

ALTER TABLE public.user_profiles
    ALTER COLUMN email TYPE email COLLATE pg_catalog."default";

CREATE OR REPLACE FUNCTION public.generate_unique_share_link()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$

 -- Declare the variables we'll be using.
DECLARE
  key TEXT;
  qry TEXT;
  found TEXT;
BEGIN

  -- generate the first part of a query as a string with safely
  -- escaped table name, using || to concat the parts
  qry := 'SELECT unique_share_link FROM ' || quote_ident(TG_TABLE_NAME) || ' WHERE unique_share_link=';

  -- This loop will probably only run once per call until we've generated
  -- millions of ids.
  LOOP

    -- Generate our string bytes and re-encode as a base64 string.
    key := encode(gen_random_bytes(6), 'base64');

    -- Base64 encoding contains 2 URL unsafe characters by default.
    -- The URL-safe version has these replacements.
    key := replace(key, '/', '_'); -- url safe replacement
    key := replace(key, '+', '-'); -- url safe replacement

    -- Concat the generated key (safely quoted) with the generated query
    -- and run it.
    -- SELECT id FROM "test" WHERE id='blahblah' INTO found
    -- Now "found" will be the duplicated id or NULL.
    EXECUTE qry || quote_literal(key) INTO found;

    -- Check to see if found is NULL.
    -- If we checked to see if found = NULL it would always be FALSE
    -- because (NULL = NULL) is always FALSE.
    IF found IS NULL THEN

      -- If we didn't find a collision then leave the LOOP.
      EXIT;
    END IF;

    -- We haven't EXITed yet, so return to the top of the LOOP
    -- and try again.
  END LOOP;

  -- NEW and OLD are available in TRIGGER PROCEDURES.
  -- NEW is the mutated row that will actually be INSERTed.
  -- We're replacing id, regardless of what it was before
  -- with our key variable.
  NEW.unique_share_link = key;

  -- The RECORD returned here is what will actually be INSERTed,
  -- or what the next trigger will get if there is one.
  RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.generate_unique_share_link()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_unique_share_link() TO authenticated;

GRANT EXECUTE ON FUNCTION public.generate_unique_share_link() TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_unique_share_link() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.generate_unique_share_link() TO anon;

GRANT EXECUTE ON FUNCTION public.generate_unique_share_link() TO service_role;

CREATE TABLE IF NOT EXISTS public.deal_accesses
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deal_id bigint NOT NULL,
    user_id uuid NOT NULL,
    unique_share_link text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT deal_accesses_pkey PRIMARY KEY (id),
    CONSTRAINT deal_accesses_deal_id_user_id_key UNIQUE (deal_id, user_id),
    CONSTRAINT deal_accesses_deal_id_fkey FOREIGN KEY (deal_id)
        REFERENCES public.deals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT deal_accesses_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.user_profiles (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.deal_accesses
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.deal_accesses TO supabase_admin;

GRANT ALL ON TABLE public.deal_accesses TO authenticated;

GRANT ALL ON TABLE public.deal_accesses TO anon;

GRANT ALL ON TABLE public.deal_accesses TO postgres;

GRANT ALL ON TABLE public.deal_accesses TO service_role;

CREATE TRIGGER deal_accesses_set_unique_link
    BEFORE INSERT OR UPDATE 
    ON public.deal_accesses
    FOR EACH ROW
    EXECUTE FUNCTION public.generate_unique_share_link();

CREATE TRIGGER deal_accesses_set_updated_at
    BEFORE INSERT OR UPDATE 
    ON public.deal_accesses
    FOR EACH ROW
    EXECUTE FUNCTION public.trigger_set_updated_at();

CREATE TABLE IF NOT EXISTS public.deal_shares
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deal_id bigint NOT NULL,
    from_user_id uuid NOT NULL,
    to_user_id uuid NOT NULL,
    CONSTRAINT deal_shares_pkey PRIMARY KEY (id),
    CONSTRAINT deal_shares_deal_id_from_user_id_to_user_id_key UNIQUE (deal_id, from_user_id, to_user_id),
    CONSTRAINT deal_shares_deal_id_fkey FOREIGN KEY (deal_id)
        REFERENCES public.deals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT deal_shares_from_user_id_fkey FOREIGN KEY (from_user_id)
        REFERENCES public.user_profiles (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT deal_shares_to_user_id_fkey FOREIGN KEY (to_user_id)
        REFERENCES public.user_profiles (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT chk_no_self_share CHECK (from_user_id <> to_user_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.deal_shares
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.deal_shares TO authenticated;

GRANT ALL ON TABLE public.deal_shares TO anon;

GRANT ALL ON TABLE public.deal_shares TO postgres;

GRANT ALL ON TABLE public.deal_shares TO service_role;

GRANT ALL ON TABLE public.deal_shares TO supabase_admin;

CREATE TRIGGER deal_shares_set_updated_at
    BEFORE INSERT OR UPDATE 
    ON public.deal_shares
    FOR EACH ROW
    EXECUTE FUNCTION public.trigger_set_updated_at();

CREATE TABLE IF NOT EXISTS public.invites
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    on_deal_id bigint,
    from_user_id uuid NOT NULL,
    to_email email COLLATE pg_catalog."default" NOT NULL,
    unique_share_link text COLLATE pg_catalog."default" NOT NULL,
    is_accepted boolean NOT NULL DEFAULT false,
    on_user_id uuid,
    CONSTRAINT invites_pkey PRIMARY KEY (id),
    CONSTRAINT invites_on_deal_id_from_user_id_to_email_key UNIQUE (on_deal_id, from_user_id, to_email),
    CONSTRAINT invites_unique_share_link_key UNIQUE (unique_share_link),
    CONSTRAINT invites_from_user_id_fkey FOREIGN KEY (from_user_id)
        REFERENCES public.user_profiles (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT invites_on_deal_id_fkey FOREIGN KEY (on_deal_id)
        REFERENCES public.deals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT invites_on_user_id_fkey FOREIGN KEY (on_user_id)
        REFERENCES public.user_profiles (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT chk_only_one_is_not_null CHECK (num_nonnulls(on_deal_id, on_user_id) = 1)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.invites
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.invites TO authenticated;

GRANT ALL ON TABLE public.invites TO anon;

GRANT ALL ON TABLE public.invites TO postgres;

GRANT ALL ON TABLE public.invites TO service_role;

GRANT ALL ON TABLE public.invites TO supabase_admin;

CREATE TRIGGER invites_set_unique_link
    BEFORE INSERT OR UPDATE 
    ON public.invites
    FOR EACH ROW
    EXECUTE FUNCTION public.generate_unique_share_link();

CREATE TRIGGER invites_set_updated_at
    BEFORE INSERT OR UPDATE 
    ON public.invites
    FOR EACH ROW
    EXECUTE FUNCTION public.trigger_set_updated_at();


CREATE OR REPLACE VIEW public.profile_page_view
    AS
     SELECT user_profile.user_id,
    user_profile.handle,
    user_profile.profile_pic_url,
    user_profile.cover_photo_url,
    user_profile.first_name,
    user_profile.last_name,
    user_profile.is_verified,
    user_profile.subtitle,
    user_profile.is_sponsor,
    user_profile.is_investor,
    user_profile.current_org_id,
    user_profile.current_org_position,
    org.profile_pic_url AS current_org_profile_pic_url,
    org.name AS current_org_name,
    user_profile.created_at,
    user_profile.nominated_by_user_id,
    nominated_by_user_profile.profile_pic_url AS nominated_by_user_profile_pic_url,
    nominated_by_user_profile.first_name AS nominated_by_user_first_name,
    nominated_by_user_profile.last_name AS nominated_by_user_last_name,
    nominated_by_user_profile.handle AS nominated_by_user_handle,
    user_profile.about,
    user_profile.connections_count,
    mutual_connections_view.mutual_connections,
    user_profile.linkedin_url,
    user_profile.facebook_url,
    user_profile.instagram_url,
    user_profile.twitter_url,
    sponsor_deals_view.deals,
    ( SELECT json_agg(endorsements.*) AS json_agg
           FROM ( SELECT endorsing_user.handle AS endorsing_user_handle,
                    endorsing_user.user_id AS endorsing_user_user_id,
                    endorsing_user.profile_pic_url AS endorsing_user_profile_pic_url,
                    endorsing_user.first_name AS endorsing_user_first_name,
                    endorsing_user.last_name AS endorsing_user_last_name,
                    endorsement.created_at,
                    endorsement.relationship,
                    endorsement.text,
                    endorsement.on_deal
                   FROM endorsements endorsement
                     JOIN user_profiles endorsing_user ON endorsement.author_user_id = endorsing_user.user_id
                  WHERE endorsement.to_user_id = user_profile.user_id) endorsements) AS endorsements
   FROM user_profiles user_profile
     LEFT JOIN organizations org ON user_profile.current_org_id = org.id
     LEFT JOIN user_profiles nominated_by_user_profile ON user_profile.nominated_by_user_id = nominated_by_user_profile.user_id
     LEFT JOIN sponsor_deals_view ON sponsor_deals_view.user_id = user_profile.user_id
     LEFT JOIN mutual_connections_view ON mutual_connections_view.user_id = user_profile.user_id;

ALTER TABLE public.organizations ALTER COLUMN handle SET NOT NULL;