## Supabase Database / Backend

We leverage a near-backend-less setup. How? Thanks to Supabase!

The frontend can in many instances directly communicate with Supabase, without going through a NextJS backend api. This is secure because of row level security.

Combined with views and database triggers/functions, we can alleviate the need for a NextJS backend API almost entirely.

### RLS (Row Level Security)

An excellent primer: https://supabase.com/docs/learn/auth-deep-dive/auth-row-level-security

We leverage Supabase to have the frontend directly interface with the database. As such, we immensely reduce the need to have a backend. This works
because of row level security. So, the logged in user will ONLY have access that the policies on the tables dictate the user has access to.

### Data storage

We also use Supabase for generic data storage (i.e. images, videos, PDFs, etc.). This works pretty seamlessly with our setup, and is essentially the same price (actually, slightly cheaper) than using Amazon S3 for storage.

See https://supabase.com/docs/guides/storage for full documentation on this. Essentially:

- File metadata is stored in the `storage.objects` table. Buckets are defined in `storage.buckets`.
- We interact with the Supabase server which ultimately returns the images. Behind the scenes, the data is actually stored in S3, and the Supabase server acts as an intermediary that looks at the authorization header to determine what kind of access the request gets, before ultimately fetching the content from S3.
- The Supabase server enforces access control, by policies defined on the `storage.objects` and `storage.buckets` metatables.
- You can use the Supabase UI under "Storage" to browse buckets, file contents, as well as the existing security access control policies.

#### Bucket: `public`.

- set to public, meaning all contents in this bucket are accessible by anyone, and we can generate public links from files here. Note that even though this bucket is public, it does not enable anyone to list all objects inside (i.e. SELECT permission).
- used for serving profile content, for example, profile pictures, cover photos, etc. under `users/`. Each user gets their own folder in here, and we have a access control policy set that allows each user to fully edit ONLY their own folder inside this bucket (i.e. `users/{user_id}/`).
- also used for serving deal content (i.e. deal images), under `deals/{deal_id}`.

#### Bucket: `private`

- this is set to private, meaning the contents in this bucket is not accessible broadly (ie there is no public URL)
- only accessible by using the API (download method https://supabase.com/docs/reference/javascript/storage-from-download)
- used for serving private files and attachments, like PDFs, pitch decks, etc.

Attachments

- `attachments/{attachment_id}/{filename}.{extension}`
- view: granted if you have view access to the attachment obj referenced by `attachment_id`
- edit: granted if you have edit access to the attachment obj's deal

### Triggers / Functions

To view triggers, in your remote Supabase instance, click Database -> Database Triggers.

To view functions, in your remote Supabase instance, click Database -> Database Functions.

Database triggers + functions help us further eliminate the need for a backend api.

### Views

We use views to simplify calls from the front end. Instead of the frontend/backend making a series of calls to fetch the data required, it only needs to make a single call
to get all the data for a given page.

We also use views as convenience subqueries for frequently used / reuseable queries.

#### Understanding a view

1. You can look at the type def for the view in `types/views.ts` to understand the response structure.
2. You can also look at the view results in your remote Supabase instance by navigating to Table Editor -> click the view under "All Views" (you probably want to prettify any JSON using https://jsonformatter.org/).
3. To view the latest view definitions, check `supabase/generated/views.sql`. These are autogenerated during migrations generation. If you need to copy+paste them, you can run

```
select pg_get_viewdef('deal_page_view', true);
```

to get the view defs. The resulting SQL isn't very readable, so highly recommended to put it through an online SQL formatter to beautify it for clarity: eversql.com/sql-query-formatter/.

#### First Order Views

First order views are views that don't depend on other views, and are depended on by second order views. Therefore, if you need to update first order views,
you may need to also update second order views (or delete and refresh both).

- friends_list_view - a view that makes querying for friends of a given user easier (it simply is the `connections` table, but has rows for both directions and also joins
  the user_profile table)
- sponsor_projects_view - a view that gives all projects for each user_id
- mutual_connections_view - a view that computes mutual connections for the currently logged in user. It uses auth.uid() to get currently logged in user.

#### Second Order Views

Second order views are views that depend on first order views and are generally more complex. For ex:

- profile_page_view - a view that fetches all data for the profile page.
- deal_page_view - a view that fetches all data for the deal page.

## Entities & Relationships: Database Design

Feel free to skim this section.

### Tables

user_profiles

- an extension of the `auth.user` class. `auth.user` is private, so cannot be queried by the anon key (this is default behavior of Supabase).
- note: joined_date is simply the default created_at
- fields
  - user_id (points to auth user table)
  - profile_pic_url
  - first_name
  - last_name
  - handle (used for links to profile page)
  - subtitle (ex: “founding president at …“)
  - current_org_id (this is deprecated, will be replaced with `organization_to_user_associations`)
  - current_org_position (same as above)
  - is_sponsor
  - is_investor
  - is_verified
  - nominated_by_user_id
  - about
  - facebook_url
  - twitter_url
  - instagram_url
  - linkedin_url
  - connections_count (this is autoset via a trigger on the connections table)
  - cover_photo_url

organizations

- groups of people
- will have its own page
- fields
  - profile_pic_url
  - name
  - about
  - linkedin_url
  - email
  - website_url
  - instagram_url
  - handle
  - cover_photo_url
  - headquarters
  - headline

organization_to_user_associations

- ties together org -> team members
- this will eventually replace current_org_id/current_org_title in user_profiles
- fields
  - org_id
  - user_id
  - is_leadership
  - order_index
  - is_current
  - job_title

endorsements

- fields
  - author_user_id
  - to_user_id
  - deal_id
  - text
  - subtitle (gives context to the endorsement: ex, “investor in a deal”)

connections

- connections are bidirectional; there's exactly a single row in this table per friendship. This means from/to don't really mean anything.
- constraint: from_user_id < to_user to enforce single row per friendship
- RLS
  - add: only if one of from_user_id or to_user_id = currently logged in user, and there's a corresponding connection_request for which currently logged in user is connection_request.to_user_id and connection_request.from_user_id is the other user
- fields
  - from_user_id
  - to_user_id

connection_requests

- requests to form a connection. A request is considered fulfilled if there is a connection in the connections table representing the
- constraint: uniqueness on (from_user_id, to_user_id), but also the reverse (meaning you cannot send a request to someone who's already sent you a request), this is handled via a pre trigger
- RLS
  - add: only if you're from_user_id
  - edit: only if you're to_user_id (to mark is_seen)
  - delete: only if you're from_user_id or to_user_id (either person can delete the request)
- fields
  - from_user_id
  - to_user_id
  - is_seen

relationships

- stores information about a particular relationship, does not necessarily mean the two are connections
- fields
  - author_user_id
  - on_user_id
  - private_notes
  - (can add in the future) relationship_type (ie what the other person is to author, for ex: investor, sponsor, etc.)

connection_requests

- when there’s a request to connect
- when the connection gets accepted, two entries are added / updated in the connections table above; one for each direction
- fields
  - from_user_id
  - to_user_id

deals

- AKA projects
- fields
  - title
  - highlight_1_name
  - highlight_1_value
  - highlight_2_name
  - highlight_2_value
  - highlight_term
  - highlight_equity_raise
  - about
  - is_active
  - interest_count (this is autoupdated based on a trigger on the deal_interest table)
  - launch_date (when the deal was launched)

deal_images

- fields
  - deal_id
  - image_url
  - order_index

deal_to_sponsor_associations

- fields

  - deal_id
  - sponsor_id
  - order_index

- represents a group of individuals that bring forth a deal. A deal can have multiple sponsor teams.
- fields
  - leader_user_id
  - sponsor_team_id

sponsor_team_to_user_associations

- fields
  - sponsor_team_id
  - user_id
  - order_index

deal_comments

- fields
  - deal_id
  - type (of deal_comment_type, which is an enum of either ANNOUNCEMENT or FAQ)
  - user_id
  - comment
  - replying_to_deal_comment_id

deal_comment_likes

- fields
  - user_id
  - deal_comment_id

deal_faqs

- captures Q/A for deal pages
- fields
  - deal_id
  - question
  - answer

deal_interest

- fields
  - deal_id
  - user_id

deal_views

- counts the number of times a deal has been viewed (does not count sponsors).
- deal must be viewed for at least 5 seconds for it to count as a view (eliminates quick transitions in / out of the page for whatever reason)
- probably worth deduping (can do this in the future). created_at = viewed_at
- fields
  - deal_id
  - user_id

deal_filenames

- deals can have files that are uploaded
- only uploadable by sponsors and their teams.
- only visible if you have view access to an attachment obj
- these deal_file objs group attachments, so you can have multiple versions of the same file
- fields
  - deal_id
  - filename

deal_attachments

- dael_attachments are deal based and version controlled. deal -> has many deal_filenames -> has many attachments (one for each version)
- edit access: sponsors on the deal + their team
- view access: sponsors on the deal + their team + any user in a conversation with a message with the attachment_id
- fields
  - deal_filename_id
  - storage_url (in format `attachments/{attachment_id}/{filename}.{extension}`, stored under `private` bucket)
  - attachment_type (ex: pdf, jpg, etc)
  - size_in_bytes
  - total_num_pages

deal_attachment_stats

- tracks stats of a deal file for a particular deal attachment and user
- fields
  - deal_attachment_id
  - user_id
  - view_count (how many times user had a view session in the webviewer)
  - progress (current page that the user is on in the attachment)

invites

- invite = to user who is NOT already on the platform (inviting them to the platform). Users are limited in invites.
- a trigger function will actually send the email after row insert
- fields
  - on_deal_id (when you want to invite someone off platform to a deal on the platform)
  - [future] on_user_id (when you want to invite someone off platform to connect with a user on the platform)
  - from_user_id
  - to_email
  - unique_share_link (autoset by trigger fn)
  - is_accepted
- RLS
  - view
    - if you're a deal sponsor, you see all for your deal
    - from_user_id can see all of their invites
  - edit
    - no capability (not needed). is_accepted can only be set by superuser. NextJS api endpoint will handle this.
  - add
    - only if you have view access to on_deal_id, and you must be from_user_id
    - limit of is_invite

deal_shares

- share = to user who is already on platform. Unlimited shares.
- Gets created in 3 ways:
  - when a user shares a deal to existing user on platform. Instantly create a deal_share at that time.
  - clicking email_share_link from an invite. Backend endpoint for this. Look up invite. Show partial deal. After signup/login, create deal_share. If signup, then set is_from_invite=True.
  - clicking unique_share_link from a deal_access. Look up deal_access. Show partial deal. Then, same as above.
- considerations: multiple shares to same user on the same deal, from multiple people
  - that's fine! we should capture that, that just means that user should really consider that deal
- a trigger function on new row will add notification to user
- fields
  - deal_id
  - from_user_id
  - to_user_id
- RLS
  - view
    - if you're a deal sponsor, you see all for your deal
    - you can see all deal_shares where you're the from_user_id or to_user_id
  - edit
    - no capability (not needed)
  - add
    - only if you have view access to deal_id, and you must be from_user_id

deal_accesses

- tracks user access to deals, and stores the unique share url.
- autogenerated by trigger function on new deal_share and new deal_to_sponsor_association
- fields
  - deal_id
  - user_id (uniqueness constraint: (user_id, deal_id))
  - unique_share_link (format for deals: /deal/{deal_handle}/{unique_share_link})
- RLS
  - view
    - if you're the deal sponsor, you see all for your deal
    - you can see all deal_access that you are the user_id
  - edit
    - no capability (not needed)
  - add
    - no capability. Autogenerated.

private_notes

- only accessible to the sponsor team, not visible to user
- fields
  - deal_id
  - user_id
  - note

conversations

- Direct messages = only 2 participants
- Group messages = more than 2 participants
- Interest level comes from the interest_level_view, tags are from association table
- Tag conversation with deal (can only tag 1 deal)
- Can filter on different deals based on badges and tags (ex: NOT done & on specific deal)
- Can save these filters on Inbox page
- Can rename conversation (default is empty)
- Can mark as done
- fields
  - title
  - is_marked_done

conversation_to_user_associations

- fields
  - user_id
  - conversation_id

conversation_changes

- tracks changes on group conversations (ie naming changes, add/remove people)
- fields
  - conversation_id
  - renamed_to
  - added_user_id
  - removed_user_id
  - CONSTRAINT: exactly one of renamed_to, added_user_id, removed_user_id present

messages

- realtime will be enabled on this database, listening for number of !is_read, so that FE gets pushed
- nudge option shows up for the latest message if there hasn't been a response, and you can only nudge once
- fields
  - conversation_id
  - content
  - user_id
  - on_deal_id
  - nudged_time
  - deal_attachment_id

message_read_receipts

- can only be accessed by the folks in the conversation
- fields
  - user_id

notifications

- DB triggers can automatically add rows to `notifications`, and then we can have email notifications hooked up listening to that table and autosend emails based on that.
- fields
  - receiving_user_id
  - from_user_id
  - notification_type (see enum below)
  - is_seen
  - debug_info (for admin / debugging purposes)
  - attached_deal_id, attached_org_id, attached_connection_request_id (wip), attached_endorsement_id (wip), attached_private_note_id (wip)
  - CONSTRAINT: at most one of the above attachments can be provided.

notification_type (enum)

See Figma designs for these notifications: https://www.figma.com/file/xCwfIkrF0VOaResOmGrlgh/Elmbase-%5BConfidential---please-do-not-share%5D?node-id=4243%3A14617&viewport=-24889%2C20593%2C1.05&t=8GaageqyGKEKaLTB-11

- LikedYourPost
  - attachment required: attached_deal_id
  - links to: deal
- PostedAComment
  - attachment required: attached_deal_id
  - links to: deal
- ExpressedInterestInYourDeal
  - attachment required: attached_deal_id
  - links to: deal
- HasAcceptedYourConnectionRequest
  - attachment required: (none)
  - links to: from_user
- WroteYouAnEndorsement
  - attachment required: (none)
  - links to: receiving_user_id
- AddedYouAsATeamMember
  - attachment required: attached_org_id
  - links to: org
- ReferredYouToANewDeal
  - attachment required: attached_deal_id
  - links to: deal
- (wip) RepostedYourDeal
- (wip) HasClosedFundraising
- (wip) IsClosingFundraisingIn7Days

waitlist_emails

- captures emails from waitlist on the home page
- fields
  - email

#### No longer planned

tags

- tabled for now. Not
- sponsors can add tags to other users
- note that interest level isn't a tag, it's dynamically computed
- note that deal is also not a tag, it will also be dynamic (there will be an association table for who has access to deals)
- fields
  - name

user_to_tag_associations

- fields
  - user_id
  - tag_id
